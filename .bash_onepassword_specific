# vim: set ft=bash:
export OP_CONFIG_DIR="$HOME/.config/op"
export OP_DISABLED="${OP_DISABLED:-false}"
export OP_CACHED_CREDENTIALS_FILE="$OP_CONFIG_DIR/credentials.yaml"

_op_sops() {
  if ! test -f "$OP_CACHED_CREDENTIALS_FILE"
  then
    log_error "1Password cached credentials file not found; run 'configure_1password_cli' to \
refresh"
    return 1
  fi

  if test -z "$OP_CREDENTIALS_SIGNING_KEY"
  then
    log_error "OP_CREDENTIALS_SIGNING_KEY is not set. Set it or import from .bash_secret_exports, \
then source .bash_onepassword_specific again."
    return 1
  fi

  if ! test -f "$OP_CONFIG_DIR/.sops.yaml"
  then
    cat >"$OP_CONFIG_DIR/.sops.yaml" <<-EOF
creation_rules:
  - path_regex: '$(basename "$OP_CACHED_CREDENTIALS_FILE")$'
    pgp: "$OP_CREDENTIALS_SIGNING_KEY"
EOF
  fi
  sops --config "$OP_CONFIG_DIR/.sops.yaml" --pgp "$OP_CREDENTIALS_SIGNING_KEY" "$@"
}

_ensure_onepassword_configured() {
  ensure_jq() {
    if ! &>/dev/null which jq
    then
      log_error "jq isn't installed. Run 'source ~/.bash_install' to \
fix this."
      return 1
    fi
  }

  ensure_not_disabled() {
    if grep -Eiq '^true$' <<< "$OP_DISABLED"
    then
      log_error "1Password helpers are disabled. Use 'op' directly."
      return 1
    fi
  }

  ensure_not_disabled && ensure_jq
}

_create_op_config_dir() {
  test -d "$OP_CONFIG_DIR" && return 0
  mkdir -p "$OP_CONFIG_DIR"
  chmod -R 700 "$OP_CONFIG_DIR"
}

_create_op_credential_cache() {
  test -e "$OP_CACHED_CREDENTIALS_FILE" && return 0

  cat >"$OP_CACHED_CREDENTIALS_FILE" <<-YAML
---
credentials:
  1password_cli_token:
  1password_otp:
  1password_password:
  1password_sk:
  1password_device_key:
  1password_email:
  1password_default_vault:
YAML
  _op_sops -e -i "$OP_CACHED_CREDENTIALS_FILE"
}

_get_cached_op_credential() {
  key="$(printf '["credentials"]["%s"]' "$1")"
  val="$(_op_sops -d --extract "$key" "$OP_CACHED_CREDENTIALS_FILE")"
  test "$val" == 'null' && val=""
  echo "$val"
}

_clear_cached_op_credential() {
  key="$(printf '["credentials"]["%s"] ""' "$1")"
  _op_sops --set "$key" "$OP_CACHED_CREDENTIALS_FILE"
}

_set_cached_op_credential() {
  if test -z "$2"
  then
    log_error "value cannot be blank; please try again."
    return 1
  fi
  key="$(printf '["credentials"]["%s"] "%s"' "$1" "$2")"
  _op_sops --set "$key" "$OP_CACHED_CREDENTIALS_FILE"
}

_get_or_ask_for_cached_op_credential() {
  key="$1"
  key_type="$2"
  no_print="${3:-false}"
  existing_val="$(_get_cached_op_credential "$key")"
  if test -n "$existing_val"
  then
    echo "$existing_val"
    return 0
  fi
  prompt="Saving your 1Password $key_type locally to your Mac. Enter it here"
  val=""
  attempts=0
  while true
  do
    if test "$attempts" -eq 3
    then
      log_error "Failed to save 1Password $key_type after three attempts."
      return 1
    fi
    if grep -Eiq '^true$' <<< "$no_print"
    then
      prompt="$prompt (You won't see any output)"
      >&2 printf "\n%s: " "$prompt"
      read -rs val
    else
      >&2 printf "%s: " "$prompt"
      read -r val
    fi
    test -n "$val" && break
    log_error "Value can't be empty."
    echo
    attempts=$((attempts+1))
  done
  _set_cached_op_credential "$1" "$val" &&
    _get_cached_op_credential "$1"
}

_op_fetch_cached_op_cred() {
  _get_or_ask_for_cached_op_credential "$1" "$2"
}

_fetch_cached_op_cred_sensitive() {
  _get_or_ask_for_cached_op_credential "$1" "$2" true
}

_get_1pass_token() {
  _get_cached_op_credential '1password_cli_token'
}

_op_cli_unauthenticated() {
  "$(brew --prefix)/bin/op" "$@"
}

_1pass_token_valid() {
  existing_token="$(_get_1pass_token)"
  test -z "$existing_token" && return 1
  _op_cli_unauthenticated vault list --session "$existing_token" &>/dev/null
}

_op_cli_authenticated() {
  _ensure_onepassword_configured || return 1
  _1pass_token_valid || _sign_into_1p_via_cli
  "$(brew --prefix)/bin/op" --account my --session "$(_get_1pass_token)" "$@"
}

_get_1pass_device_key() {
  _get_cached_op_credential '1password_device_key'
}

_get_1pass_otp() {
  _clear_cached_op_credential '1password_otp'
  _op_fetch_cached_op_cred "1password_otp" "OTP" || return 1
}

_get_1pass_password() {
  _fetch_cached_op_cred_sensitive "1password_password" "password"
}

_get_1pass_secret_key() {
  _fetch_cached_op_cred_sensitive "1password_sk" "secret key"
}

_get_1pass_email() {
  _op_fetch_cached_op_cred "1password_email" "email address"
}

_clear_1pass_email() {
  _clear_cached_op_credential '1password_email'
}

_clear_1pass_sk() {
  _clear_cached_op_credential '1password_sk'
}

_clear_1pass_pw() {
  _clear_cached_op_credential '1password_password'
}

_get_1pass_default_vault() {
  _op_fetch_cached_op_cred "1password_default_vault" "default vault"
}

_sign_into_1p_via_cli() {
  _op_account_exists() {
    _op_cli_unauthenticated account list | grep -q "$1"
  }

  _add_account_to_op() {
    email=$(_get_1pass_email) || return 1
    _op_account_exists && return 0

    secret_key=$(_get_1pass_secret_key) || return 1
    export OP_SECRET_KEY="$secret_key"
    password=$(_get_1pass_password) || return 1
    # This is a bug with the terminal package in Golang.
    # https://github.com/golang/go/issues/19909
    otp="$(_get_1pass_otp)" || return 1
    { sleep 2; \
      echo "$password"; \
      echo "$otp"; } | _op_cli_unauthenticated account add --address my --email "$email" && return 0
    rc="$?"
    _clear_1pass_email
    _clear_1pass_sk
    _clear_1pass_pw
    return "$rc"
  }

  _get_signin_token() {
    secret_key=$(_get_1pass_secret_key) || return 1
    export OP_SECRET_KEY="$secret_key"
    password=$(_get_1pass_password) || return 1
    # This is a bug with the terminal package in Golang.
    # https://github.com/golang/go/issues/19909
    if test -n "$REENTER_OP_OTP"
    then
      otp="$(_get_1pass_otp)" || return 1
      token_data="$({ sleep 2; \
        echo "$password"; \
        echo "$otp"; } | _op_cli_unauthenticated signin -f)" || return 1
    else
      token_data="$({ sleep 2; \
        echo "$password"; } | _op_cli_unauthenticated signin -f)" || return 1
    fi
    grep -E '^export' <<< "$token_data" | cut -f2 -d '=' | tr -d '"'
  }

  _1pass_token_valid && return 0

  _add_account_to_op || return 1

  token=$(_get_signin_token "$1") || return 1
  _set_cached_op_credential '1password_cli_token' "$token"
}

_1pass_app_integration_enabled() {
  settings_file="$HOME/Library/Group Containers/2BUA8C4S2C.com.1password/Library/Application Support/1Password/Data/settings/settings.json"
  test -e "$settings_file" &&
    test "$(jq -r '."developers.cliSharedLockState.enabled"' "$settings_file")" == 'true'
}

_op_verify_that_we_are_on_a_mac() {
  if ! test "$(get_os_type)" == "Darwin"
  then
    log_warning "1Password CLI is not supported on $(get_os_type) yet."
    return 0
  fi
}

_generate_1pass_device_key() {
  existing_device_key="$(_get_cached_op_credential '1password_device_key')"
  test -n "$existing_device_key" && return 0
  _set_cached_op_credential '1password_device_key' \
    "$(head -c 16 /dev/urandom | base32 | tr -d = | tr '[:upper:]' '[:lower:]')"
}

list_password_titles() {
  vault="$1"
  list_titles() {
    vault="$1"
    if test -z "$vault"
    then
      _op_cli_authenticated item list --format=json | jq -r .[].title
    else
      _op_cli_authenticated item list --format=json --vault "$vault" | jq -r .[].title
    fi
  }

  _ensure_onepassword_configured && list_titles "$vault"
}

list_password_titles_matching_regex() {
  list_password_titles | grep -E "$1"
}

list_password_titles_in_vault() {
  list_password_titles "$1"
}

list_password_titles_in_vault_matching_regex() {
  list_password_titles "$1" | grep -E "$2"
}

list_vaults() {
  list() {
    _op_cli_authenticated vault list --format=json | jq -r .[].name
  }
  _ensure_onepassword_configured && list
}

get_item_json() {
  local title vault
  title="$1"
  vault="$2"
  if test -z "$vault"
  then _op_cli_authenticated item get "$title" --format json
  else _op_cli_authenticated item get "$title" --format json --vault "$vault"
  fi
}

op_edit_item() {
  local title vault
  title="$1"
  vault="$2"
  if test -z "$vault"
  then _op_cli_authenticated item edit "$title" "${@:2}"
  else _op_cli_authenticated item edit "$title" "${@:2}"
  fi
}

get_password_field() {
  get() {
    title="$1"
    field="$2"
    vault="$3"
    if test -z "$vault"
    then
      if test "$field" == "otp"
      then
        _op_cli_authenticated item get "$title" --otp --reveal
      else
        _op_cli_authenticated item get "$title" --fields="$field" --reveal
      fi
    else
      if test "$field" == "otp"
      then
        _op_cli_authenticated item get --vault "$vault" "$title" --fields="$field" --otp --reveal
      else
        _op_cli_authenticated item get --vault "$vault" "$title" --fields="$field" --reveal
      fi
    fi
  }

  _ensure_onepassword_configured || return 1
  result=$(get "$1" "$2" "$3")
  test -z "$result" && result="no password found"
  echo "$result"
}

get_password_otp() {
  get_password_field "$1" 'otp' "$2"
}

get_password() {
  get_password_field "$1" 'password' "$2"
}

get_password_by_name_regexp() {
  pattern="$1"
  vault="$2"
  list_password_titles "$vault" |
    grep -E "$pattern" |
    while read -r password
    do get_password "$password" "$vault"
    done
}

get_password_by_name() {
  pattern="$1"
  vault="$2"
  get_password "$pattern" "$vault"
}

_get_1pass_functions() {
  grep -E '^[a-z].*() {' $HOME/src/setup/.bash_onepassword_specific |
    grep -Ev '^ensure' |
    grep -Ev '_get_1pass_functions' |
    sed 's/() {//'
}

_op_configure_cli() {
  _onepass_has_not_been_run_before() {
    ! test -d "$OP_CONFIG_DIR"
  }

  if _1pass_app_integration_enabled
  then
    log_info "INFO: 1Password CLI app integration is enabled; there's nothing to configure!"
    return 0
  fi

  _ensure_onepassword_configured || return 1
  _op_verify_that_we_are_on_a_mac
  if _onepass_has_not_been_run_before
  then
    _create_op_config_dir && _create_op_credential_cache && _generate_1pass_device_key
  fi
  export OP_DEVICE=$(_get_1pass_device_key)
  _sign_into_1p_via_cli && return 0
  log_error "Signing into 1Password unsuccessful. If you saw a prompt to enter an OTP, \
run this command again, but with REENTER_OP_OTP=1 behind it."
  return 1
}

_op_list_password_titles() {
  _op_cli_authenticated item list --vault "$(_op_get_vault_or_fail "$1")" --format=json |
    jq -r .[].title
}

_op_download_file() {
  local file_name dest vault is_regexp
  file_name="$1"
  dest="$2"
  vault="$3"
  is_regexp="$4"
  item="$file_name"
  test -n "$is_regexp" && item=$(_op_list_password_titles "$vault" | grep -E "$file_name")
  if test "$(wc -l <<< "$item")" -gt 1
  then
    log_error "Multiple matches found for '$item'; please narrow your pattern down."
    return 1
  fi
  _op_cli_authenticated document get "$item" --out-file "$dest" \
    --vault "$(_op_get_vault_or_fail "$vault")"
}

_op_get_password() {
  _op_get_password_field "$1" 'password' "$2"
}

_op_get_vault_or_fail() {
  vaults=$(_op_cli_authenticated vault list | grep "$1")
  if test "$(wc -l <<< "$vaults")" -gt 1
  then
    log_error "Too many 1Password vaults match vault '$vault'"
    return 1
  fi
  cut -f1 -d ' ' <<< "$vaults"
}

_op_get_password_field() {
  get() {
    title="$1"
    field="$2"
    vault="$3"
    if test "$field" == 'otp'
    then
      _op_cli_authenticated item get "$title" --otp --reveal \
        --vault "$(_op_get_vault_or_fail "$vault")"
    else
      _op_cli_authenticated item get "$title" --field="$field" \
        --vault "$(_op_get_vault_or_fail "$vault")"
    fi
  }

  result=$(get "$1" "$2" "$3")
  test -z "$result" && result="no password found"
  echo "$result"
}
# op_list_password_titles [VAULT]: Lists passwords in a vault.
# OP_DEFAULT_VAULT is used if `[VAULT]` is not provided.
op_list_password_titles() {
  _op_list_password_titles "$1"
}

# op_list_password_titles [REGEXP] [VAULT]: Lists passwords in a vault that match a regexp.
# OP_DEFAULT_VAULT is used if `[VAULT]` is not provided.
op_list_password_titles_matching_regex() {
  _op_list_password_titles "$2" | grep -E "$1"
}

# op_list_vaults: Lists vaults in a 1Password account.
op_list_vaults() {
  _op_cli_authenticated vault list --format=json | jq -r .[].name
}

# op_get_password_field TITLE FIELD [VAULT]: Gets a field in a 1Password 'password' item.
# Set FIELD to "otp" to get a password's one-time password, if one is defined.
#
# EXAMPLES
#
# `op_get_password_field "My Item" "address" "My Vault"`: Gets the 'address' field from
# the "My Item" item in "My Vault".
#
# `op_get_password_field "My Item" "otp"`: Gets the one-time password for the 'My Item'
# item in the vault that `$OP_DEFAULT_VAULT` is set to.
# (Note: Using `op_get_password_otp "My Item" "My Vault"` is recommended for getting
#  OTPs.)
#
# `op_get_password_field "My Item" "password" "My Vault"`: Gets the password from
# the "My Item" item in "My Vault".
# (Note: Using `op_get_password_by_name "My Item" "My Vault"` is recommended for getting
#  passwords.)
op_get_password_field() {
  _op_get_password_field "$1" "$2" "$3"
}

# op_get_password_otp TITLE [VAULT]: Gets a one-time password in a 1Password
# 'password' item. This only works if the item has a "one-time password" field set.
op_get_password_otp() {
  _op_get_password_field "$1" 'otp' "$2"
}

# op_get_password TITLE [VAULT]: Gets a password in a 1Password 'password' item. by name.
op_get_password_by_name() {
  pattern="$1"
  vault="$2"
  _op_get_password "$pattern" "$vault"
}

# op_get_password_by_name_regexp REGEXP [VAULT]: Gets a password in a 1Password
# 'password' item that matches a regexp.
op_get_password_by_name_regexp() {
  pattern="$1"
  vault="$2"
  _op_list_password_titles "$vault" |
    grep -E "$pattern" |
    while read -r password
    do _op_get_password "$password" "$vault"
    done
}

# op_download_file_by_name FILE_NAME OUTPUT_FILE [VAULT]: Downloads a file
# attached to a 1Password item by the item's name.
op_download_file_by_name() {
  file_name="$1"
  dest="$2"
  vault="$3"
  _op_download_file "$file_name" "$dest" "$vault"
}

# op_download_file_by_name_regexp REGEXP OUTPUT_FILE [VAULT]: Downloads a file
# attached to a 1Password item matching a regular expression. This will fail
# if multiple items match the expression.
op_download_file_by_name_regexp() {
  file_name="$1"
  dest="$2"
  vault="$3"
  _op_download_file "$file_name" "$dest" "$vault" re
}

_op_upload_file() {
  local name input tags vault is_str
  name="$1"
  input="$2"
  tags="$3"
  vault="$4"
  is_str="$5"
  if test -n "$is_str"
  then
    data="$input"
    fname='from_string'
  else
    data=$(cat "$input")
    fname="$(basename "$file")"
  fi
  if test -n "$(_op_list_password_titles "$vault" | grep "$name")"
  then
    echo "$data" | op_cli document edit "$name" - \
      --title "$name" \
      --tags "$tags" \
      --vault "$(_op_get_vault_or_fail "$vault")"
  else
    echo "$data" | op_cli document create - --title "$name" \
      --file-name "$fname" \
      --tags "$tags" \
      --vault "$(_op_get_vault_or_fail "$vault")"
  fi
}

_op_create_password() {
  local name input tags vault is_str
  name="$1"
  category="$2"
  tags="$3"
  vault="$4"
  fields="${@:5}"
  if test -n "$(_op_list_password_titles "$vault" | grep "$name")"
  then
    op_cli item edit "$name" \
      --title "$name" \
      --vault "$(_op_get_vault_or_fail "$vault")" \
      "${fields[*]}"
  else
    op_cli item create \
      --title "$name" \
      --category "$category" \
      --vault "$(_op_get_vault_or_fail "$vault")" \
      ${fields[@]}
  fi
}

# op_upload_file NAME INPUT_FILE [TAGS] [VAULT]: Creates a 1Password item called NAME
# inside of VAULT and uploads INPUT_FILE into it.
op_upload_file() {
  _op_upload_file "$1" "$2" "$3" "$4"
}

# op_upload_file_from_string NAME STRING [TAGS] [VAULT]: Creates a 1Password item called NAME
# inside of VAULT and uploads the contents of STRING into it.
op_upload_file_from_string() {
  _op_upload_file "$1" "$2" "$3" "$4" string
}

# op_create_password NAME TAGS USERNAME PASSWORD FIELDS... [VAULT]: Creates an item in 1Password inside of
# VAULT.
op_create_password() {
  if test "$#" -lt 4
  then
    log_error "op_create_password: Must provide at least four arguments."
    return 1
  fi
  local category title tags username password vault fields
  category=Login
  title="$1"
  shift
  tags="$1"
  shift
  username="$1"
  shift
  password="$1"
  shift
  fields=()
  while test "$#" -ne 0
  do
    val="$1"
    if grep -q '=' <<< "$val"
    then fields+=($val)
    else vault="$val"
    fi
    shift
  done
  _op_create_password "$title" "$category" "$tags" "$vault" \
    "username=$username" "password=$password" ${fields[@]}
}

# op_create_private_key_from_string NAME TAGS PKDATA [FIELDS...] [VAULT]: Creates a private key item in 1Password
# inside of VAULT.
op_create_private_key_from_string() {
  if test "$#" -lt 3
  then
    log_error "op_create_private_key: Must provide at least three arguments."
    return 1
  fi
  local category title tags username password vault fields
  category="Password"
  title="$1"
  shift
  tags="$1"
  shift
  pkdata="$1"
  shift
  fields=()
  while test "$#" -ne 0
  do
    val="$1"
    if grep -q '=' <<< "$val"
    then fields+=($val)
    else vault="$val"
    fi
    shift
  done
  tmpfile="${TMPDIR:-/tmp}/opclipk.XXXXX"
  mktemp "$tmpfile"
  echo "$pkdata" > "$tmpfile"
  _op_create_password "$title" "$category" "$tags" "$vault" \
    "password='private_key'" \
    "private_key[file]=$tmpfile" ${fields[@]}
  rc=$?
  rm "$tmpfile"
  return "$rc"
}

# op_cli: Convenience function for other scripts wanting to interact with
# 1Password (since newer versions of op are more anal about session keys
# and stuff).
op_cli() {
  _op_cli_authenticated "$@"
}

# op_configure_cli: Configures the 1Password CLI interactively. Requires
# OP_CREDENTIALS_SIGNING_KEY to be set to the fingerprint of a GPG private key
# installed on the system. Configuration data is encrypted with this key and stored
# in $HOME/.config/op with sops.
op_configure_cli() {
  if test "$FROM_BASH_INSTALL" != 'true' && test -t 1
  then
    log_error 'Run "eval $(configure_1password_cli)" instead.'
    return 1
  fi
  _op_configure_cli
}

if [[ $- == *i* ]]
then
  alias op-cli=_op_cli_authenticated
  alias get_1pass_functions=_get_1pass_functions
  alias onepass_functions=_get_1pass_functions
  if ! _1pass_app_integration_enabled
  then
    log_info "Run 'configure_1password_cli' to start using 1Password in your terminal."
    log_info "If your account has two-factor authentication enabled, \
    provide ONEPASSWORD_OTP=[YOUR_OTP] before running 'eval \$(configure_1password_cli)'."
  fi
fi
